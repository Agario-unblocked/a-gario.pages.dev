var Vector2 = function(t, n) { this.x = t || 0, this.y = n || 0 };
Vector2.prototype = {
    reset: function(t, n) { return this.x = t, this.y = n, this },
    toString: function(t) { t = t || 3; var n = Math.pow(10, t); return "[" + Math.round(this.x * n) / n + ", " + Math.round(this.y * n) / n + "]" },
    clone: function() { return new Vector2(this.x, this.y) },
    copyTo: function(t) { t.x = this.x, t.y = this.y },
    copyFrom: function(t) { this.x = t.x, this.y = t.y },
    magnitude: function() { return Math.sqrt(this.x * this.x + this.y * this.y) },
    magnitudeSquared: function() { return this.x * this.x + this.y * this.y },
    normalise: function() { var t = this.magnitude(); return this.x = this.x / t, this.y = this.y / t, this },
    reverse: function() { return this.x = -this.x, this.y = -this.y, this },
    plusEq: function(t) { return this.x += t.x, this.y += t.y, this },
    plusNew: function(t) { return new Vector2(this.x + t.x, this.y + t.y) },
    minusEq: function(t) { return this.x -= t.x, this.y -= t.y, this },
    minusNew: function(t) { return new Vector2(this.x - t.x, this.y - t.y) },
    multiplyEq: function(t) { return this.x *= t, this.y *= t, this },
    multiplyNew: function(t) { return this.clone().multiplyEq(t) },
    divideEq: function(t) { return this.x /= t, this.y /= t, this },
    divideNew: function(t) { return this.clone().divideEq(t) },
    dot: function(t) { return this.x * t.x + this.y * t.y },
    angle: function(t) { return Math.atan2(this.y, this.x) * (t ? 1 : Vector2Const.TO_DEGREES) },
    rotate: function(t, n) {
        var i = Math.cos(t * (n ? 1 : Vector2Const.TO_RADIANS)),
            s = Math.sin(t * (n ? 1 : Vector2Const.TO_RADIANS));
        return Vector2Const.temp.copyFrom(this), this.x = Vector2Const.temp.x * i - Vector2Const.temp.y * s, this.y = Vector2Const.temp.x * s + Vector2Const.temp.y * i, this
    },
    equals: function(t) { return this.x == t.x && this.y == t.x },
    isCloseTo: function(t, n) { return !!this.equals(t) || (Vector2Const.temp.copyFrom(this), Vector2Const.temp.minusEq(t), Vector2Const.temp.magnitudeSquared() < n * n) },
    rotateAroundPoint: function(t, n, i) { Vector2Const.temp.copyFrom(this), Vector2Const.temp.minusEq(t), Vector2Const.temp.rotate(n, i), Vector2Const.temp.plusEq(t), this.copyFrom(Vector2Const.temp) },
    isMagLessThan: function(t) { return this.magnitudeSquared() < t * t },
    isMagGreaterThan: function(t) { return this.magnitudeSquared() > t * t }
}, Vector2Const = { TO_DEGREES: 180 / Math.PI, TO_RADIANS: Math.PI / 180, temp: new Vector2 };

var selectSkinModalAjax = 0;
var selectSkinName = "";

var port = 443;
var CONNECTION_URL = "ffa5.agariodns.cyou:" + port;
var playGameClickEvent = 0;

function appendHtmlChild() {
    if (localStorage.gameMode && localStorage.gameMode != undefined && localStorage.gameMode != null) {
        document.querySelector('#gamemode [value="' + localStorage.gameMode + '"]').selected = true;
    }
    if (localStorage.playerNick && localStorage.playerNick != undefined && localStorage.playerNick != null) {
        document.getElementById("nick").value = localStorage.playerNick;
    } else {
        document.getElementById("nick").value = location.hostname;
    }
    if (localStorage.skin && localStorage.skin != undefined && localStorage.skin != null) {
        document.getElementById("preview-img-area").innerHTML = `<img id="selectSkinImg" width="150" onclick="selectSkinPage(); return false;" src="./skins/${localStorage.skin}.png" class="img-circle img-raised img-responsive">`;
        selectSkinName = localStorage.skin;
    } else {
        document.getElementById("preview-img-area").innerHTML = `<img id="selectSkinImg" width="150" onclick="selectSkinPage(); return false;" src="./skins/noskin.png" class="img-circle img-raised img-responsive">`;
    }
   // document.getElementById("idFlags").innerHTML = `
	//<a href="/" aria-label="Switch tr page"><img src="imgs/flag-tr.png" width="32" height="32" alt="TR Flag"></a>
	//<a href="/en" aria-label="Switch en page"><img src="imgs/flag-en.png" width="32" height="32" alt="EN Flag"></a>
	//<a href="/es" aria-label="Switch es page"><img src="imgs/flag-es.png" width="32" height="32" alt="ES Flag"></a>
	//<a href="/de" aria-label="Switch de page"><img src="imgs/flag-de.png" width="32" height="32" alt="DE Flag"></a>
	//`
	;
}

document.addEventListener('DOMContentLoaded', (e) => {
    console.log(`Game is ready`);
    appendHtmlChild();
    setserver(CONNECTION_URL);
    document.querySelector("body").onkeyup = function(e) {
        if (e.keyCode == 13) {
            if (document.getElementById("overlays").style.display == "none") {
                document.getElementById("chat_textbox").focus();
            }
        }
    }
});

function getScript(scriptUrl, callback) {
    const script = document.createElement('script');
    script.src = scriptUrl;
    script.onload = callback;
    document.body.appendChild(script);
}


(function(wHandle, wjQuery) {
    wHandle.setserver = function() {
        var arg = document.getElementById('gamemode').value;
        if (arg != gameMode) {
            CONNECTION_URL = arg;
            gameMode = arg;
            wsConnect(CONNECTION_URL);
            localStorage.gameMode = arg;
        }
    };

    wHandle.mobile_OpenSettings = function() {
        document.getElementById("mobile_settingsModal").style.display = "block";
    }

    wHandle.mobile_CloseSettings = function() {
        document.getElementById("mobile_settingsModal").style.display = "none";
    }

    wHandle.mobile_OpenSelectSkinPage = function() {
        document.getElementById("skinModal").style.display = "block";
        if (selectSkinModalAjax == 0) {
            getScript("./skins.js", () => selectSkinModalAjax = 1)
        }

    }

    wHandle.selectSkinPage = function() {
        document.getElementById("skinModal").style.display = "block";
        if (selectSkinModalAjax == 0) {
            if (selectSkinModalAjax == 0) {
                getScript("./skins.js", () => selectSkinModalAjax = 1)
            }
        }
    }

    wHandle.closeSkinPage = function() {
        document.getElementById("skinModal").style.display = "none";
    }

    wHandle.setSkinListClick = function(value) {
        document.getElementById("selectSkinImg").src = "./skins/" + value + ".png";
        closeSkinPage();
        localStorage.skin = value;
        selectSkinName = value;
        console.log(value + " 'skin update'");
    }

    function insideBox(ix, iy, ax, ay, x, y) {
        if (ix <= x && x <= ax && iy <= y && y <= ay) {
            return true;
        }
        return false;
    }

    Element.prototype.hide = function() {
        this.style.display = "none";
        if (this.style.opacity == 1) this.style.opacity = 0;
    };

    Element.prototype.show = function(seconds) {
        this.style.display = "";
        var that = this;
        if (seconds) {
            this.style.transition = "opacity " + seconds + "s ease 0s";
            setTimeout(function() {
                that.style.opacity = 1;
            }, 20);
        }
    };


    var SKIN_URL = "./skins/";
    var touchX, touchY,
        // is this running in a touch capable environment?
        touchable = 'createTouch' in document,
        touches = []; // array of touch vectors

    var leftTouchID = -1,
        leftTouchPos = new Vector2(0, 0),
        leftTouchStartPos = new Vector2(0, 0),
        leftVector = new Vector2(0, 0);

    var txtpos_width = 100;
    var txtpos_height = 20;
    var txtpos_share = "!";
    var txtpos_lastTime = 0;


    var mapx = 0;
    var mapy = 0;
    var mapDstX = 0;
    var mapDstY = 0;
    var drawMapDstPoint = false;

    var cursor_x_old = 0,
        cursor_y_old = 0;

    var localProtocol = wHandle.location.protocol,
        localProtocolHttps = "https:" == localProtocol;
    var nCanvas, ctx, mainCanvas, lbCanvas, chatCanvas, canvasWidth, canvasHeight, qTree = null,
        ws = null,
        nodeX = 0,
        nodeY = 0,
        nodesOnScreen = [],
        playerCells = [],
        nodes = {},
        nodelist = [],
        Cells = [],
        leaderBoard = [],
        lastWinner = '?',
        gameName = '?',
        countdown = 3600,
        chatBoard = [],
        rawMouseX = 0,
        rawMouseY = 0,
        X = -1,
        Y = -1,
        cb = 0,
        rb = Date.now(),
        R = 0,
        Sa = 0,
        timestamp = 0,
        leftPos = 0,
        topPos = 0,
        rightPos = 1E4,
        bottomPos = 1E4,
        viewZoom = 1,
        w = null,
        noSkin = false,
        noNames = false,
        noColor = false,
        ua = false,
        userScoreCurrent = 0,
        userScoreMax = 0,
        showDarkTheme = false,
        showScore = false,
        simpleGreen = false,
        smoothRender = .4,
        transparentRender = false,
        hideChat = false,
        getZoom = false,
        posX = nodeX = ~~((leftPos + rightPos) / 2),
        posY = nodeY = ~~((topPos + bottomPos) / 2),
        posSize = 1,
        gameMode = "",
        teamScores = null,
        hasOverlay = true,
        drawLine = false,
        lineX = 0,
        lineY = 0,
        drawLineX = 0,
        drawLineY = 0,
        Ra = 0,
        teamColor = ["#333333", "#FF3333", "#33FF33", "#3333FF"],
        zoom = 0.4,
        isTouchStart = "ontouchstart" in wHandle && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
        noRanking = false;
    var wCanvas = document.createElement("canvas");
    wHandle.isSpectating = false;

    var lastSendMouseMove = Date.now();

    var mapNEW_x = 0;
    var mapNEW_y = 0;

    function window_onLoad() {
		// copy paste iptal
		const chatbox = document.querySelector('#chat_textbox');
		chatbox.addEventListener('paste', e => e.preventDefault())
		//
        var isTouchDevice = 'ontouchstart' in document.documentElement;
        if (isTouchDevice == true) {
            document.getElementById("leftWrapper_Top").innerHTML = '';
            document.getElementById("leftWrapper_Bottom").innerHTML = '';
            document.getElementById("rightWrapper_Top").innerHTML = '';
            document.getElementById("rightWrapper_Bottom").innerHTML = '';
        } else {
            document.getElementById("mobile_settingsModal").innerHTML = '';
        }

        if (localStorage.noSkin == null)
            localStorage.noSkin = false;
        noSkin = (localStorage.noSkin === 'true');
        document.getElementById("noSkin").checked = noSkin;

        if (localStorage.noNames == null)
            localStorage.noNames = false;
        noNames = (localStorage.noNames === 'true');
        document.getElementById("noNames").checked = noNames;

        if (localStorage.noColor == null)
            localStorage.noColor = false;
        noColor = (localStorage.noColor === 'true');
        document.getElementById("noColor").checked = noColor;

        if (localStorage.showDarkTheme == null)
            localStorage.showDarkTheme = false;
        showDarkTheme = (localStorage.showDarkTheme === 'true');
        document.getElementById("darkTheme").checked = showDarkTheme;

        if (localStorage.hideChat == null)
            localStorage.hideChat = false;
        hideChat = (localStorage.hideChat === 'true');
        document.getElementById("hideChat").checked = hideChat;
        if (hideChat) {
            document.getElementById("chat_textbox").style.display = "none";
        } else {
            document.getElementById("chat_textbox").style.display = "block";
        }

        if (localStorage.smoothRender == null)
            localStorage.smoothRender = .4;
        smoothRender = localStorage.smoothRender;
        document.getElementById("smoothRender").checked = (smoothRender == 2);

        if (localStorage.transparentRender == null)
            localStorage.transparentRender = false;
        transparentRender = (localStorage.transparentRender === 'true');
        document.getElementById("transparentRender").checked = transparentRender;

        if (localStorage.showScore == null)
            localStorage.showScore = false;
        showScore = (localStorage.showScore === 'true');
        document.getElementById("showScore").checked = showScore;

        if (localStorage.zoom == null)
            localStorage.zoom = true;
        getZoom = (localStorage.zoom === 'true');
        document.getElementById("getZoom").checked = getZoom;

        document.getElementById("canvas").focus();
        var isTyping = false;
        var chattxt;
        mainCanvas = nCanvas = document.getElementById("canvas");
        ctx = mainCanvas.getContext("2d");

        mainCanvas.onmousemove = function(event) {
            rawMouseX = event.clientX;
            rawMouseY = event.clientY;
            mouseCoordinateChange();
        };

        mainCanvas.onmousedown = function(event) {
            var x = event.clientX; // - elemLeft;
            var y = event.clientY; // - elemTop;
            var deltaT = (new Date()).getTime() - txtpos_lastTime;
            if (deltaT > 5000 && x >= mapNEW_x && x <= (mapNEW_x + txtpos_width) && y >= ((mapNEW_y - 15) - txtpos_height) && y <= mapNEW_y - 15) {
                sendChat(txtpos_share);
                txtpos_lastTime = (new Date()).getTime();
            }
        };

        if (touchable) {
            mainCanvas.addEventListener('touchstart', onTouchStart, false);
            mainCanvas.addEventListener('touchmove', onTouchMove, false);
            mainCanvas.addEventListener('touchend', onTouchEnd, false);
        }

        mainCanvas.onmouseup = function() {

        };
        if (/firefox/i.test(navigator.userAgent)) {
            document.addEventListener("DOMMouseScroll", handleWheel, false);
        } else {
            document.body.onmousewheel = handleWheel;
        }

        mainCanvas.onfocus = function() {
            isTyping = false;
        };

        document.getElementById("chat_textbox").onblur = function() {
            isTyping = false;
        };

        document.getElementById("chat_textbox").onfocus = function() {
            isTyping = true;
        };

        var spacePressed = false,
            qPressed = false,
            wPressed = false;

        var ePressed = false;

        var int_e = 0;

        wHandle.onkeydown = function(event) {
            var vMenu = document.getElementById("overlays").style.display;

            switch (event.keyCode) {
                case 32: // split
                    if (!spacePressed && !isTyping && vMenu == "none") {
                        sendMouseMove();
                        sendUint8(17);
                        spacePressed = true;
                    }
                    break;
                case 81: // key q pressed
                    if (!qPressed && vMenu == "none") {
                        sendUint8(18);
                        qPressed = true;
                    }
                    break;
                case 87: // eject mass
                    if (!wPressed && !isTyping && vMenu == "none") {
                        sendMouseMove();
                        sendUint8(21);
                        wPressed = true;
                    }
                    break;
                case 27: // quit
                    showOverlays("fast");
                    wHandle.isSpectating = false;
                    break;

                case 13:
                    if (isTyping) {
                        isTyping = false;
                        document.getElementById("chat_textbox").blur();
                        chattxt = document.getElementById("chat_textbox").value;

                        if (chattxt.length > 0)
                            sendChat(chattxt);
                        document.getElementById("chat_textbox").value = "";
                    } else {
                        if (!hasOverlay) {
                            isTyping = true;
                        }
                    }
                    break;
                case 69:
                    if ((!ePressed) && (!isTyping) && vMenu == "none") {
                        ePressed = true;
                        sendUint8(22);
                    }
                    if (int_e == 0) {
                        int_e = setInterval(function() {
                            wHandle.onkeydown({ keyCode: 87 });
                            wHandle.onkeyup({ keyCode: 87 });
                        }, 0);
                    }
                    break;
            }
        };
        wHandle.onkeyup = function(event) {
            switch (event.keyCode) {
                case 32:
                    spacePressed = false;
                    break;
                case 87:
                    wPressed = false;
                    break;
                case 81:
                    if (qPressed) {
                        sendUint8(19);
                        qPressed = false;
                    }
                    break;
                case 69:
                    if (ePressed) {
                        ePressed = false;
                        sendUint8(23);
                    }
                    if (int_e != 0) {
                        clearInterval(int_e);
                        int_e = 0;
                    }
                    break;
            }
        };
        wHandle.onblur = function() {
            //sendUint8(19);
            wPressed = qPressed = spacePressed = false
        };

        wHandle.onresize = canvasResize;
        canvasResize();
        if (wHandle.requestAnimationFrame) {
            wHandle.requestAnimationFrame(redrawGameScene);
        } else {
            setInterval(drawGameScene, 1E3 / 60);
        }

        document.getElementById("overlays").style.display = "block";
        document.getElementById("infoOverlays").style.display = "none";
    }

    function onTouchStart(e) {

    }

    function onTouchMove(e) {

    }

    function onTouchEnd(e) {

    }

    function handleWheel(event) {
        if (getZoom) {
            zoom *= Math.pow(.9, event.wheelDelta / -120 || event.detail || 0);
            0.4 > zoom && (zoom = 0.4);
            zoom > 10 / viewZoom && (zoom = 10 / viewZoom)
        } else {
            zoom *= Math.pow(.9, event.wheelDelta / -120 || event.detail || 0);
            0.01 > zoom && (zoom = 0.01);
            zoom > 4 / viewZoom && (zoom = 4 / viewZoom)
        }
    }

    function buildQTree() {
        if (.4 > viewZoom) qTree = null;
        else {
            var a = Number.POSITIVE_INFINITY,
                b = Number.POSITIVE_INFINITY,
                c = Number.NEGATIVE_INFINITY,
                d = Number.NEGATIVE_INFINITY,
                e = 0;
            for (var i = 0; i < nodelist.length; i++) {
                var node = nodelist[i];
                if (node.shouldRender() && !node.prepareData && 20 < node.size * viewZoom) {
                    e = Math.max(node.size, e);
                    a = Math.min(node.x, a);
                    b = Math.min(node.y, b);
                    c = Math.max(node.x, c);
                    d = Math.max(node.y, d);
                }
            }
            qTree = Quad.init({
                minX: a - (e + 100),
                minY: b - (e + 100),
                maxX: c + (e + 100),
                maxY: d + (e + 100),
                maxChildren: 2,
                maxDepth: 4
            });
            for (i = 0; i < nodelist.length; i++) {
                node = nodelist[i];
                if (node.shouldRender() && !(20 >= node.size * viewZoom)) {
                    for (a = 0; a < node.points.length; ++a) {
                        b = node.points[a].x;
                        c = node.points[a].y;
                        b < nodeX - canvasWidth / 2 / viewZoom || c < nodeY - canvasHeight / 2 / viewZoom || b > nodeX + canvasWidth / 2 / viewZoom || c > nodeY + canvasHeight / 2 / viewZoom || qTree.insert(node.points[a]);
                    }
                }
            }
        }
    }

    function mouseCoordinateChange() {
        X = (rawMouseX - canvasWidth / 2) / viewZoom + nodeX;
        Y = (rawMouseY - canvasHeight / 2) / viewZoom + nodeY
    }

    function hideOverlays() {
        hasOverlay = false;
        document.getElementById("overlays").hide(1.0);
    }

    function showOverlays(arg) {
        hasOverlay = true;
        if (arg == "fast") {
            document.getElementById("overlays").show(0.2);
        } else {
            document.getElementById("overlays").show(0.5);
        }
    }

    function showDeathInfoOverlays() {
        document.getElementById("stats_hightesmass").innerHTML = userScoreMax;
        document.getElementById("stats_timealive").innerHTML = Cb((Date.now() - rb) / 1E3);
        document.getElementById("stats_topposition").innerHTML = 0 == R ? ":(" : R;
        document.getElementById("infoOverlays").show(0.5);
    }

    function $b() {
        if (null == leaderBoard) return 0;
        for (var a = 0; a < leaderBoard.length; ++a)
            if (-1 != nodesOnScreen.indexOf(leaderBoard[a].id)) return a + 1;
        return 0

    }

    function ps(n, a) {
        if (n.indexOf('{') != -1 && n.indexOf('}') != -1) {
            var s = n.indexOf('{');
            var e = n.indexOf('}');
            var c = n.slice(e + 1);
            if (a) {
                if (c == '') {
                    c = 'UnnamedCell';
                } else {
                    c = n.slice(e + 1);
                }
            }
            return [n.slice(s + 1, e), c];
        } else {
            return ['', n];
        }
    }

    function Cb(a) {
        a = ~~a;
        var b = (a % 60).toString();
        a = (~~(a / 60)).toString();
        2 > b.length && (b = "0" + b);
        return a + ":" + b
    }

    function wsConnect(wsUrl) {
        if (ws) {
            ws.onopen = null;
            ws.onmessage = null;
            ws.onclose = null;
            try {
                ws.close();
            } catch (b) {
                console.log("Connection not closed");
            }
            ws = null
        }
        var c = CONNECTION_URL;
        wsUrl = "wss://" + c;
        nodesOnScreen = [];
        playerCells = [];
        nodes = {};
        nodelist = [];
        Cells = [];
        leaderBoard = [];
        lastWinner = '?';
        this.countdown = 3600;
        mainCanvas = teamScores = null;
        userScoreMax = 0;
        userScoreCurrent = 0;
        Sa = 0;
        ws = new WebSocket(wsUrl, ["protocol1", "protocol2"]);

        ws.binaryType = "arraybuffer";
        ws.onopen = onWsOpen;
        ws.onmessage = onWsMessage;
        ws.onclose = onWsClose;
        ws.onerror = function(e) {
            console.log(e);
        }
    }

    function prepareData(a) {
        return new DataView(new ArrayBuffer(a))
    }

    function wsSend(a) {
        ws.send(a.buffer)
    }

    function sendPlayInit() {
        sendNickName();
        sendHandshakeRequest();
    }

    function onWsOpen() {
        console.log("Connected to the game");

        var msg = prepareData(5);
        msg.setUint8(0, 254);
        msg.setUint32(1, 4, true);
        wsSend(msg);
        var msg;
        msg = prepareData(5);
        msg.setUint8(0, 255);
        msg.setUint32(1, 1332175218, true);
        wsSend(msg);
        if (playGameClickEvent == 1) {
            sendPlayInit();
        }
    }

    function onWsClose() {
        playGameClickEvent = 0;
        console.log("Connection closed");
        ws = null;
        showOverlays("fast");
        wHandle.isSpectating = false;
    }

    function onWsMessage(msg) {
        try {
            handleWsMessage(new DataView(msg.data))
        } catch (b) {
            console.log("Ws Message could not be sent");
        }
    }

    function handleWsMessage(msg) {
        function getString() {
            var text = '',
                char;
            while ((char = msg.getUint16(offset, true)) != 0) {
                offset += 2;
                text += String.fromCharCode(char);
            }
            offset += 2;
            return text;
        }

        var offset = 0,
            setCustomLB = false;
        240 == msg.getUint8(offset) && (offset += 5);
        switch (msg.getUint8(offset++)) {
            case 16: // update nodes
                updateNodes(msg, offset);
                break;
            case 17: // update position
                posX = msg.getFloat32(offset, true);
                offset += 4;
                posY = msg.getFloat32(offset, true);
                offset += 4;
                posSize = msg.getFloat32(offset, true);
                offset += 4;
                break;
            case 20: // clear nodes
                playerCells = [];
                nodesOnScreen = [];
                break;
            case 21: // draw line
                lineX = msg.getInt16(offset, true);
                offset += 2;
                lineY = msg.getInt16(offset, true);
                offset += 2;
                if (!drawLine) {
                    drawLine = true;
                    drawLineX = lineX;
                    drawLineY = lineY;
                }
                break;
            case 32: // add node
                nodesOnScreen.push(msg.getUint32(offset, true));
                offset += 4;
                break;
            case 48: // update leaderboard (custom text)
                setCustomLB = true;
                noRanking = true;
                break;
            case 49: // update leaderboard (ffa)
                if (!setCustomLB) {
                    noRanking = false;
                }
                teamScores = null;
                var LBplayerNum = msg.getUint32(offset, true);
                offset += 4;
                leaderBoard = [];
                for (i = 0; i < LBplayerNum; ++i) {
                    var nodeId = msg.getUint32(offset, true);
                    offset += 4;
                    leaderBoard.push({
                        id: nodeId,
                        name: getString()
                    })
                }
                drawLeaderBoard();
                break;
            case 50: // update leaderboard (teams)
                teamScores = [];
                var LBteamNum = msg.getUint32(offset, true);
                offset += 4;
                for (var i = 0; i < LBteamNum; ++i) {
                    teamScores.push(msg.getFloat32(offset, true));
                    offset += 4;
                }
                drawLeaderBoard();
                break;
            case 64: // set border
                leftPos = msg.getFloat64(offset, true);
                offset += 8;
                topPos = msg.getFloat64(offset, true);
                offset += 8;
                rightPos = msg.getFloat64(offset, true);
                offset += 8;
                bottomPos = msg.getFloat64(offset, true);
                offset += 8;
                posX = (rightPos + leftPos) / 2;
                posY = (bottomPos + topPos) / 2;
                posSize = 1;
                if (0 == playerCells.length) {
                    nodeX = posX;
                    nodeY = posY;
                    viewZoom = posSize;
                }
                break;
            case 92:
                this.gameName = '';
                var ch;
                while ((ch = msg.getUint16(offset, true)) != 0) {
                    offset += 2;
                    this.gameName += String.fromCharCode(ch);
                }
                break;
            case 96:
                this.countdown = msg.getUint16(offset, true);
                break;
            case 97: //last winner
                lastWinner = '';
                var ch;
                while ((ch = msg.getUint16(offset, true)) != 0) {
                    offset += 2;
                    lastWinner += String.fromCharCode(ch);
                }
                break;
            case 99:
                addChat(msg, offset);
                break;
        }
    }

    function addChat(view, offset) {
        function getString() {
            var text = '',
                char;
            while ((char = view.getUint16(offset, true)) != 0) {
                offset += 2;
                text += String.fromCharCode(char);
            }
            offset += 2;
            return text;
        }

        var flags = view.getUint8(offset++);
        // for future expansions
        if (flags & 2) {
            offset += 4;
        }
        if (flags & 4) {
            offset += 8;
        }
        if (flags & 8) {
            offset += 16;
        }

        var r = view.getUint8(offset++),
            g = view.getUint8(offset++),
            b = view.getUint8(offset++),
            color = (r << 16 | g << 8 | b).toString(16);
        while (color.length > 6) {
            color = '0' + color;
        }
        color = '#' + color;
        chatBoard.push({
            "name": ps(getString())[1],
            "color": color,
            "message": getString(),
            "time": Date.now()
        });
    }

    function updateNodes(view, offset) {
        timestamp = +new Date;
        var code = Math.random();
        ua = false;
        var queueLength = view.getUint16(offset, true);
        offset += 2;
        for (i = 0; i < queueLength; ++i) {
            var killer = nodes[view.getUint32(offset, true)],
                killedNode = nodes[view.getUint32(offset + 4, true)];
            offset += 8;
            if (killer && killedNode) {
                killedNode.destroy();
                killedNode.ox = killedNode.x;
                killedNode.oy = killedNode.y;
                killedNode.oSize = killedNode.size;
                killedNode.nx = killer.x;
                killedNode.ny = killer.y;
                killedNode.nSize = killedNode.size;
                killedNode.updateTime = timestamp;
            }
        }
        for (var i = 0;;) {
            var nodeid = view.getUint32(offset, true);
            offset += 4;
            if (0 == nodeid) break;
            ++i;
            var size, posY, posX = view.getInt16(offset, true);
            offset += 2;
            posY = view.getInt16(offset, true);
            offset += 2;
            size = view.getInt16(offset, true);
            offset += 2;
            for (var r = view.getUint8(offset++), g = view.getUint8(offset++), b = view.getUint8(offset++),
                    color = (r << 16 | g << 8 | b).toString(16); 6 > color.length;) color = "0" + color;
            var colorstr = "#" + color,
                flags = view.getUint8(offset++),
                flagVirus = !!(flags & 1),
                flagAgitated = !!(flags & 16);
            flags & 2 && (offset += 4);
            flags & 4 && (offset += 8);
            flags & 8 && (offset += 16);
            for (var char, name = "";;) {
                char = view.getUint16(offset, true);
                offset += 2;
                if (0 == char) break;
                name += String.fromCharCode(char)
            }
            var node = null;
            if (nodes.hasOwnProperty(nodeid)) {
                node = nodes[nodeid];
                node.updatePos();
                node.ox = node.x;
                node.oy = node.y;
                node.oSize = node.size;
                node.color = colorstr;
            } else {
                node = new Cell(nodeid, posX, posY, size, colorstr, name);
                nodelist.push(node);
                nodes[nodeid] = node;
                node.ka = posX;
                node.la = posY;
            }
            node.isVirus = flagVirus;
            node.isAgitated = flagAgitated;
            node.nx = posX;
            node.ny = posY;
            node.nSize = size;
            node.updateCode = code;
            node.updateTime = timestamp;
            node.flag = flags;
            name && node.setName(name);
            if (-1 != nodesOnScreen.indexOf(nodeid) && -1 == playerCells.indexOf(node)) {
                document.getElementById("overlays").style.display = "none";
                playerCells.push(node);
                if (1 == playerCells.length) {
                    nodeX = node.x;
                    nodeY = node.y;
                }
            }
        }
        queueLength = view.getUint32(offset, true);
        offset += 4;
        for (i = 0; i < queueLength; i++) {
            var nodeId = view.getUint32(offset, true);
            offset += 4;
            node = nodes[nodeId];
            null != node && node.destroy();
        }
        ua && 0 == playerCells.length && showDeathInfoOverlays("slow");

        if (playerCells.length == 0 && drawMapDstPoint == true) {
            mapDstX = mapx;
            mapDstY = mapy;
        }
    }


    function sendMouseMove() {
        var msg;
        if (wsIsOpen()) {
            msg = rawMouseX - canvasWidth / 2;
            var b = rawMouseY - canvasHeight / 2;
            if (64 <= msg * msg + b * b && !(.01 > Math.abs(oldX - X) && .01 > Math.abs(oldY - Y))) {
                oldX = X;
                oldY = Y;
                msg = prepareData(21);
                msg.setUint8(0, 16);
                msg.setFloat64(1, X, true);
                msg.setFloat64(9, Y, true);
                msg.setUint32(17, 0, true);
                wsSend(msg);
            }
        }
    }

    function sendHandshakeRequest() {
        if (wsIsOpen()) {
            var msg = prepareData(1);
            msg.setUint8(0, 27);
            wsSend(msg)
        }
    }

    function sendNickName() {
        var nick = document.getElementById('nick').value;
        localStorage.playerNick = nick;
        if (selectSkinName != "") {
            nick = "{" + selectSkinName + "}" + nick;
        }
        if (wsIsOpen()) {
            var msg = prepareData(1 + 2 * nick.length);
            msg.setUint8(0, 0);
            for (var i = 0; i < nick.length; ++i) msg.setUint16(1 + 2 * i, nick.charCodeAt(i), true);
            wsSend(msg);
        }
    }

    function sendChat(str) {
        if (wsIsOpen() && (str.length < 200) && (str.length > 0)) {
            var msg = prepareData(2 + 2 * str.length);
            var offset = 0;
            msg.setUint8(offset++, 99);
            msg.setUint8(offset++, 0); // flags (0 for now)
            for (var i = 0; i < str.length; ++i) {
                msg.setUint16(offset, str.charCodeAt(i), true);
                offset += 2;
            }

            wsSend(msg);
        }
    }

    function wsIsOpen() {
        return null != ws && ws.readyState == ws.OPEN
    }

    function sendUint8(a) {
        if (wsIsOpen()) {
            var msg = prepareData(1);
            msg.setUint8(0, a);
            wsSend(msg)
        }
    }

    function redrawGameScene() {
        drawGameScene();
        wHandle.requestAnimationFrame(redrawGameScene)
    }

    function canvasResize() {
        window.scrollTo(0, 0);
        canvasWidth = wHandle.innerWidth;
        canvasHeight = wHandle.innerHeight;
        nCanvas.width = canvasWidth;
        nCanvas.height = canvasHeight;

        var hello = document.getElementById("helloDialog");
        hello.style.transform = "none";
        var modalHeight = hello.clientHeight;
        modalHeight > canvasHeight / 1.1 ? hello.style.transform = "translate(-50%, -50%) scale(" + canvasHeight / modalHeight / 1.1 + ")" : hello.style.transform = "translate(-50%, -50%)";
        drawGameScene();
    }

    function viewRange() {
        var ratio;
        ratio = Math.max(canvasHeight / 1080, canvasWidth / 1920);
        return ratio * zoom;
    }

    function calcViewZoom() {
        if (0 != playerCells.length) {
            for (var newViewZoom = 0, i = 0; i < playerCells.length; i++) newViewZoom += playerCells[i].size;
            newViewZoom = Math.pow(Math.min(64 / newViewZoom, 1), .4) * viewRange();
            viewZoom = (9 * viewZoom + newViewZoom) / 10
        }
    }

    function drawGameScene() {
        var a, oldtime = Date.now();
        ++cb;

        var deltaT = Date.now() - lastSendMouseMove;

        if (deltaT > 50) {
            lastSendMouseMove = Date.now();
            sendMouseMove();
        }

        timestamp = oldtime;
        if (0 < playerCells.length) {
            calcViewZoom();
            var c = a = 0;
            for (var d = 0; d < playerCells.length; d++) {
                playerCells[d].updatePos();
                a += playerCells[d].x / playerCells.length;
                c += playerCells[d].y / playerCells.length;
            }
            posX = a;
            posY = c;
            posSize = viewZoom;
            nodeX = (nodeX + a) / 2;
            nodeY = (nodeY + c) / 2
        } else {
            nodeX = (29 * nodeX + posX) / 30;
            nodeY = (29 * nodeY + posY) / 30;
            viewZoom = (9 * viewZoom + posSize * viewRange()) / 10;
        }
        buildQTree();
        mouseCoordinateChange();

        ctx.fillStyle = showDarkTheme ? "#111111" : "#F2FBFF";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        nodelist.sort(function(a, b) {
            return a.size == b.size ? a.id - b.id : a.size - b.size
        });

        ctx.save();
        ctx.translate(canvasWidth / 2, canvasHeight / 2);
        ctx.scale(viewZoom, viewZoom);
        ctx.translate(-nodeX, -nodeY);

        // border -->
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = 50;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        ctx.moveTo(leftPos, topPos);
        ctx.lineTo(rightPos, topPos);
        ctx.lineTo(rightPos, bottomPos);
        ctx.lineTo(leftPos, bottomPos);
        ctx.closePath();
        ctx.stroke();
        // <--

        if (transparentRender == true) {
            ctx.globalAlpha = 0.6;
        } else {
            ctx.globalAlpha = 1;
        }

        for (d = 0; d < nodelist.length; d++) {
            nodelist[d].drawOneCell(ctx);
        }

        if (drawLine) {
            drawLineX = (3 * drawLineX + lineX) /
                4;
            drawLineY = (3 * drawLineY + lineY) / 4;
            ctx.save();
            ctx.strokeStyle = "#FFAAAA";
            ctx.lineWidth = 10;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.globalAlpha = .5;
            ctx.beginPath();
            for (d = 0; d < playerCells.length; d++) {
                ctx.moveTo(playerCells[d].x, playerCells[d].y);
                ctx.lineTo(drawLineX, drawLineY);
            }
            ctx.stroke();
            ctx.restore()
        }

        ctx.restore();

        lbCanvas && lbCanvas.width && ctx.drawImage(lbCanvas, canvasWidth - lbCanvas.width - 10, 10); // draw Leader Board
        if (!hideChat) {
            if ((chatCanvas != null) && (chatCanvas.width > 0)) ctx.drawImage(chatCanvas, 0, canvasHeight - chatCanvas.height - 50); // draw Chat Board
        }

        // score -->
        userScoreCurrent = calcUserScore();
        userScoreMax = Math.max(userScoreMax, userScoreCurrent);

        ctx.globalAlpha = .8;
        if (showDarkTheme == true) {
            ctx.fillStyle = '#FFFFFF';
        } else {
            ctx.fillStyle = '#000000';
        }
        ctx.font = "24px Ubuntu";
        ctx.fillText('Score: ' + userScoreCurrent, 10, 34);
        ctx.fillText('Max: ' + userScoreMax, 10, 60);
        // countdown -->
        if (this.countdown < 3600) {
            var countDownStr = "";

            var min = Math.floor(this.countdown / 60);
            if (min < 10) {
                countDownStr += "0";
            }
            countDownStr += min + ":";

            var sec = this.countdown % 60;
            if (sec < 10) {
                countDownStr += "0";
            }
            countDownStr += sec;

            ctx.globalAlpha = .4;
            if (showDarkTheme == false) {
                ctx.fillStyle = "#000000";
            } else {
                ctx.fillStyle = "#DDDDDD";
            }

            ctx.globalAlpha = 1;
            if (showDarkTheme == true) {
                ctx.fillStyle = "#5959eb";
            } else {
                ctx.fillStyle = "#0000FF";
            }
            ctx.font = "17px Ubuntu";
            ctx.fillText("Restart " + countDownStr, 10, 90);
        }
        // <--

        // <--

        if (wsIsOpen()) {
            ctx.globalAlpha = 1;
            ctx.font = "16px Ubuntu";

            var txt_share = 'share';

            var txt = Math.round(nodeX / 1000) + ' , ' + Math.round(nodeY / 1000) + ' ' + txt_share;
            txtpos_width = ctx.measureText(txt).width;
            txtpos_height = 16;
            txtpos_share = '*** ' + Math.round(nodeX / 1000) + ' , ' + Math.round(nodeY / 1000) + ' ***';
            if (showDarkTheme == true) {
                ctx.fillStyle = '#FFFFFF';
            } else {
                ctx.fillStyle = '#000000';
            }
            ctx.fillText(txt, mapNEW_x, mapNEW_y - 15);
            // <--
        }

        // chatboard --->
        if (hideChat == false) {
            var cnt = 0;
            for (var i = chatBoard.length - 1; i >= 0; i--) {
                cnt++;
                if (cnt > 15) {
                    break;
                }

                var name = chatBoard[i].name.trim();
                if (name == '') {
                    name = 'Agar.io';
                }
                var msgRaw = chatBoard[i].message.trim();
                var msgFull = " : " + msgRaw;

                ctx.font = "18px Arial";

                chatBoard[i].name_x = 15;
                chatBoard[i].name_y = (canvasHeight - 30) - 20 * cnt;
                chatBoard[i].name_w = ctx.measureText(name).width;
                chatBoard[i].name_h = 18;

                chatBoard[i].msg_x = 15 + chatBoard[i].name_w;
                chatBoard[i].msg_y = chatBoard[i].name_y;
                chatBoard[i].msg_w = ctx.measureText(msgFull).width;
                chatBoard[i].msg_h = chatBoard[i].name_h;

                ctx.fillStyle = chatBoard[i].color;
                ctx.fillText(name, chatBoard[i].name_x, chatBoard[i].name_y);

                if (showDarkTheme == true) {
                    ctx.fillStyle = "#FFFFFF";
                } else {
                    ctx.fillStyle = "#000000";
                }

                ctx.fillText(msgFull, chatBoard[i].msg_x, chatBoard[i].msg_y);
            }
        }
        // <---

        var deltatime = Date.now() - oldtime;
        deltatime > 1E3 / 60 ? z -= .01 : deltatime < 1E3 / 65 && (z += .01);
        .4 > z && (z = .4);
        1 < z && (z = 1)

        drawMap();

    }

    function drawMap() {
        if (playerCells.length == 0) return;
        ctx.save();

        function gcd(a, b) {
            return !b ? a : gcd(b, a % b);
        }
        ctx.beginPath();
        ctx.fillStyle = "rgba(0,0,0,.25)";
        var size = 200;
        ctx.lineWidth = 1.5;
        var mapX = canvasWidth - size - 10;
        var mapY = canvasHeight - size - 5;
        ctx.rect(mapX, mapY, size, size);
        ctx.lineWidth = 1.25;

        var newX = nodeX / (rightPos - leftPos);
        var newY = nodeY / (bottomPos - topPos);
        var posX = (newX * size + mapX) + size / 2 - 100;
        var posY = (newY * size + mapY) + size / 2 - 100;
        var bw = bh = size;
        var insideX = -1;
        var insideY = -1;
        for (var x = 0; x <= bw; x += 40) {
            if (x != bw) {
                var ix = 0.5 + x + mapX;
                var iy = mapY;
                if (insideBox(ix, iy, ix + 40, iy + bh, posX, posY)) {
                    insideX = ix;
                }
                if (x == 0) continue;
                ctx.moveTo(0.5 + x + mapX, mapY);
                ctx.lineTo(0.5 + x + mapX, bh + mapY);
            }

            if (showDarkTheme == true) {
                ctx.fillStyle = "#FFFFFF";
            } else {
                ctx.fillStyle = "#000000";
            }

            ctx.font = "700 18px ubuntu";
            ctx.textAlign = "center";
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.35;
            for (var i = 0; i < 5; i++) {
                ctx.fillText(String.fromCharCode(i + 65) + x / 40, (0.5 + x + mapX) - 20, mapY + 25.5 + (i * 40));
            }
        }

        for (var y = 0; y <= bh; y += 40) {
            if (y != bh) {
                var ix = mapX;
                var iy = 0.5 + y + mapY;
                if (insideBox(ix, iy, ix + bw, iy + 40, posX, posY)) {
                    insideY = iy;
                }
                if (y == 0) continue;
                ctx.moveTo(mapX, 0.5 + y + mapY);
                ctx.lineTo(bw + mapX, 0.5 + y + mapY);

            }

        }

        if (playerCells.length > 0 && insideX > -1 && insideY > -1) {
            ctx.fillStyle = "#ccff00";
            ctx.globalAlpha = 0.3;
            ctx.fillRect(insideX, insideY, 40, 40);

        }

        ctx.globalAlpha = 1;
        ctx.strokeStyle = "rgba(255,255,255,.2)";
        ctx.stroke();
        ctx.closePath();

        for (var i = 0; i < playerCells.length; i++) {
            var player = playerCells[i];
            var ox = player.ox / (rightPos - leftPos);
            var oy = player.oy / (bottomPos - topPos);
            var x = (ox * size + mapX) + size / 2 - 100;
            var y = (oy * size + mapY) + size / 2 - 100;
            var mass = Math.max(2, player.size / (size / 2));
            ctx.fillStyle = player.color;
            if (i == 0) {
                ctx.font = "bold " + (14 + mass) + "px Ubuntu";
                var measure = ctx.measureText(player.name);
                ctx.strokestyle = "black";
            }

            ctx.beginPath();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 1;
            ctx.arc(x, y, mass, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
        }
        ctx.restore();

    }

    function drawGrid() {
        ctx.fillStyle = showDarkTheme ? "#111111" : "#F2FBFF";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.save();
        ctx.strokeStyle = showDarkTheme ? "#AAAAAA" : "#000000";
        ctx.globalAlpha = .2;
        ctx.scale(viewZoom, viewZoom);
        var a = canvasWidth / viewZoom,
            b = canvasHeight / viewZoom;
        for (var c = -.5 + (-nodeX + a / 2) % 50; c < a; c += 50) {
            ctx.beginPath();
            ctx.moveTo(c, 0);
            ctx.lineTo(c, b);
            ctx.stroke();
        }
        for (c = -.5 + (-nodeY + b / 2) % 50; c < b; c += 50) {
            ctx.beginPath();
            ctx.moveTo(0, c);
            ctx.lineTo(a, c);
            ctx.stroke();
        }
        ctx.restore()
    }


    function calcUserScore() {
        for (var score = 0, i = 0; i < playerCells.length; i++) {
            score += playerCells[i].getScore();
        }

        return score
    }

    function drawLeaderBoard() {
        lbCanvas = null;
        var drawTeam = null != teamScores;
        if (drawTeam || 0 != leaderBoard.length)
            lbCanvas = document.createElement("canvas");
        var ctx = lbCanvas.getContext("2d"),
            boardLength = 60;
        boardLength = !drawTeam ? boardLength + 24 * leaderBoard.length : boardLength + 180;
        var scaleFactor = Math.min(0.22 * canvasHeight, Math.min(200, .3 * canvasWidth)) * 0.005;
        lbCanvas.width = 200 * scaleFactor;
        lbCanvas.height = boardLength * scaleFactor;

        ctx.scale(scaleFactor, scaleFactor);
        ctx.globalAlpha = .4;
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, 200, boardLength);

        ctx.globalAlpha = 1;
        ctx.fillStyle = "#FFFFFF";
        var c = "Leaderboard";
        ctx.font = "30px Ubuntu";
        ctx.fillText(c, 100 - ctx.measureText(c).width * 0.5, 40);
        var b, l;
        if (!drawTeam) {
            for (ctx.font = "20px Ubuntu", b = 0, l = leaderBoard.length; b < l; ++b) {
                c = ps(leaderBoard[b].name)[1] || "An unnamed cell";
                if (noNames) {
                    (c = "An unnamed cell");
                }
                var me = -1 != nodesOnScreen.indexOf(leaderBoard[b].id);
                if (me) playerCells[0].name && (c = ps(playerCells[0].name)[1]);
                me ? ctx.fillStyle = "#FFAAAA" : ctx.fillStyle = "#FFFFFF";
                if (!noRanking) c = b + 1 + ". " + c;
                var start = (ctx.measureText(c).width > 200) ? 2 : 100 - ctx.measureText(c).width * 0.5;
                ctx.fillText(c, start, 70 + 24 * b);
            }
        } else {
            for (b = c = 0; b < teamScores.length; ++b) {
                var d = c + teamScores[b] * Math.PI * 2;
                ctx.fillStyle = teamColor[b + 1];
                ctx.beginPath();
                ctx.moveTo(100, 140);
                ctx.arc(100, 140, 80, c, d, false);
                ctx.fill();
                c = d
            }
        }
    }

    function Cell(uid, ux, uy, usize, ucolor, uname) {
        this.id = uid;
        this.ox = this.x = ux;
        this.oy = this.y = uy;
        this.oSize = this.size = usize;
        this.color = ucolor;
        this.points = [];
        this.pointsAcc = [];
        this.createPoints();
        this.setName(uname)
    }

    function UText(usize, ucolor, ustroke, ustrokecolor) {
        usize && (this._size = usize);
        ucolor && (this._color = ucolor);
        this._stroke = !!ustroke;
        ustrokecolor && (this._strokeColor = ustrokecolor)
    }


    wHandle.playGame = function() {
        userScoreCurrent = 0;
        userScoreMax = 0;

        if (document.getElementById('nick').value.trim() == "") {
            alert("Enter a nick");
            return;
        }

        hideOverlays();

        if (ws == null || ws.readyState == 2 || ws.readyState == 3) {
            playGameClickEvent = 1;
            wsConnect();
        } else {
            sendPlayInit();
        }

        rb = Date.now();
        R = 0;
    };

    wHandle.spectate = function() {
        wHandle.isSpectating = true;
        hideOverlays();

        if (ws == null || ws.readyState == 2 || ws.readyState == 3) {
            wsConnect();
        } else {
            sendUint8(1);
        }
    };

    wHandle.setHideSkins = function(arg) {
        arg = document.getElementById('noSkin').checked;
        noSkin = arg;
        localStorage.noSkin = arg;
    };
    wHandle.setHideNames = function(arg) {
        arg = document.getElementById('noNames').checked;
        noNames = arg;
        localStorage.noNames = arg;
    };
    wHandle.setDarkTheme = function(arg) {
        arg = document.getElementById('darkTheme').checked;
        showDarkTheme = arg;
        localStorage.showDarkTheme = arg;
    };
    wHandle.setNoColor = function(arg) {
        arg = document.getElementById('noColor').checked;
        noColor = arg;
        localStorage.noColor = arg;
    };

    wHandle.setSmooth = function(arg) {
        arg = document.getElementById('smoothRender').checked;
        smoothRender = arg ? 2 : .4;
        localStorage.smoothRender = arg ? 2 : .4;
    };
    wHandle.setTransparent = function(arg) {
        arg = document.getElementById('transparentRender').checked;
        transparentRender = arg;
        localStorage.transparentRender = arg;
    };
    wHandle.setShowScore = function(arg) {
        arg = document.getElementById('showScore').checked;
        showScore = arg;
        localStorage.showScore = arg;
    };
    wHandle.setSimpleGreen = function(arg) {
        arg = document.getElementById('simpleGreen').checked;
        simpleGreen = arg;
        localStorage.simpleGreen = arg;
    };
    wHandle.setHideChat = function(arg) {
        arg = document.getElementById('hideChat').checked;
        hideChat = arg;
        localStorage.hideChat = arg;
        if (arg) {
            document.getElementById("chat_textbox").style.display = "none";
        } else {
            document.getElementById("chat_textbox").style.display = "block";
        }
    };
    wHandle.setZoom = function(arg) {
        arg = document.getElementById('getZoom').checked;
        getZoom = arg;
        localStorage.zoom = arg;
    };
    setInterval(function() {
        var a = $b();
        if (0 != a) {
            ++Sa;
            if (0 == R) {
                R = a;
            }
            R = Math.min(R, a);
        }
    }, 1E3);

    var delay = 500,
        oldX = -1,
        oldY = -1,
        Canvas = null,
        z = 1,
        scoreText = null,
        skins = {},
        skinsLoaded = {},
        //knownNameDict = [],
        //knownNameDict_noDisp = ["8", "nasa"],
        ib = ["_canvas'blob"];
    Cell.prototype = {
        id: 0,
        points: null,
        pointsAcc: null,
        name: null,
        skinName: null,
        hasSkinName: false,
        nameCache: null,
        sizeCache: null,
        x: 0,
        y: 0,
        size: 0,
        ox: 0,
        oy: 0,
        oSize: 0,
        nx: 0,
        ny: 0,
        nSize: 0,
        flag: 0, //what does this mean
        updateTime: 0,
        updateCode: 0,
        drawTime: 0,
        destroyed: false,
        isVirus: false,
        isAgitated: false,
        wasSimpleDrawing: true,
        destroy: function() {
            var tmp;
            for (tmp = 0; tmp < nodelist.length; tmp++)
                if (nodelist[tmp] == this) {
                    nodelist.splice(tmp, 1);
                    break
                }
            delete nodes[this.id];
            tmp = playerCells.indexOf(this);
            if (-1 != tmp) {
                ua = true;
                playerCells.splice(tmp, 1);
            }
            tmp = nodesOnScreen.indexOf(this.id);
            if (-1 != tmp) {
                nodesOnScreen.splice(tmp, 1);
            }
            this.destroyed = true;
            Cells.push(this)
        },
        getNameSize: function() {
            return Math.max(~~(.3 * this.size), 24)
        },
        setName: function(a) {
            if (this.name = a) {
                if (null == this.nameCache) {
                    this.nameCache = new UText(this.getNameSize(), "#FFFFFF", true, "#000000");
                    this.nameCache.setValue(this.name);
                } else {
                    this.nameCache.setSize(this.getNameSize());
                    this.nameCache.setValue(this.name);
                }
            }
        },
        setSkinName: function(a) {
            this.skinName = a;
        },
        createPoints: function() {
            for (var samplenum = this.getNumPoints(); this.points.length > samplenum;) {
                var rand = ~~(Math.random() * this.points.length);
                this.points.splice(rand, 1);
                this.pointsAcc.splice(rand, 1)
            }
            if (0 == this.points.length && 0 < samplenum) {
                this.points.push({
                    ref: this,
                    size: this.size,
                    x: this.x,
                    y: this.y
                });
                this.pointsAcc.push(Math.random() - .5);
            }
            while (this.points.length < samplenum) {
                var rand2 = ~~(Math.random() * this.points.length),
                    point = this.points[rand2];
                this.points.splice(rand2, 0, {
                    ref: this,
                    size: point.size,
                    x: point.x,
                    y: point.y
                });
                this.pointsAcc.splice(rand2, 0, this.pointsAcc[rand2])
            }
        },
        getNumPoints: function() {
            if (0 == this.id) return 16;
            var a = 10;
            if (20 > this.size) a = 0;
            if (this.isVirus) a = 30;
            var b = this.size;
            if (!this.isVirus)(b *= viewZoom);
            b *= z;
            if (this.flag & 32)(b *= .25);
            return ~~Math.max(b, a);
        },
        movePoints: function() {
            this.createPoints();
            for (var points = this.points, pointsacc = this.pointsAcc, numpoints = points.length, i = 0; i < numpoints; ++i) {
                var pos1 = pointsacc[(i - 1 + numpoints) % numpoints],
                    pos2 = pointsacc[(i + 1) % numpoints];
                pointsacc[i] += (Math.random() - .5) * (this.isAgitated ? 3 : 1);
                pointsacc[i] *= .7;
                10 < pointsacc[i] && (pointsacc[i] = 10); -
                10 > pointsacc[i] && (pointsacc[i] = -10);
                pointsacc[i] = (pos1 + pos2 + 8 * pointsacc[i]) / 10
            }
            for (var ref = this, isvirus = this.isVirus ? 0 : (this.id / 1E3 + timestamp / 1E4) % (2 * Math.PI), j = 0; j < numpoints; ++j) {
                var f = points[j].size,
                    e = points[(j - 1 + numpoints) % numpoints].size,
                    m = points[(j + 1) % numpoints].size;
                if (15 < this.size && null != qTree && 20 < this.size * viewZoom && 0 != this.id) {
                    var l = false,
                        n = points[j].x,
                        q = points[j].y;
                    qTree.retrieve2(n - 5, q - 5, 10, 10, function(a) {
                        if (a.ref != ref && 25 > (n - a.x) * (n - a.x) + (q - a.y) * (q - a.y)) {
                            l = true;
                        }
                    });
                    if (!l && points[j].x < leftPos || points[j].y < topPos || points[j].x > rightPos || points[j].y > bottomPos) {
                        l = true;
                    }
                    if (l) {
                        if (0 < pointsacc[j]) {
                            (pointsacc[j] = 0);
                        }
                        pointsacc[j] -= 1;
                    }
                }
                f += pointsacc[j];
                0 > f && (f = 0);
                f = this.isAgitated ? (19 * f + this.size) / 20 : (12 * f + this.size) / 13;
                points[j].size = (e + m + 8 * f) / 10;
                e = 2 * Math.PI / numpoints;
                m = this.points[j].size;
                this.isVirus && 0 == j % 2 && (m += 5);
                points[j].x = this.x + Math.cos(e * j + isvirus) * m;
                points[j].y = this.y + Math.sin(e * j + isvirus) * m
            }
        },
        updatePos: function() {
            if (0 == this.id) return 1;
            var a;
            a = (timestamp - this.updateTime) / 120;
            a = 0 > a ? 0 : 1 < a ? 1 : a;
            var b = 0 > a ? 0 : 1 < a ? 1 : a;
            this.getNameSize();
            if (this.destroyed && 1 <= b) {
                var c = Cells.indexOf(this); -
                1 != c && Cells.splice(c, 1)
            }
            this.x = a * (this.nx - this.ox) + this.ox;
            this.y = a * (this.ny - this.oy) + this.oy;
            this.size = b * (this.nSize - this.oSize) + this.oSize;
            return b;
        },
        shouldRender: function() {
            if (0 == this.id) {
                return true
            } else {
                return !(this.x + this.size + 40 < nodeX - canvasWidth / 2 / viewZoom || this.y + this.size + 40 < nodeY - canvasHeight / 2 / viewZoom || this.x - this.size - 40 > nodeX + canvasWidth / 2 / viewZoom || this.y - this.size - 40 > nodeY + canvasHeight / 2 / viewZoom);
            }
        },
        getScore: function() {
            var r = ~~(this.nSize * this.nSize / 100);
            return r;
        },
        drawOneCell: function(ctx) {
            if (this.shouldRender()) {
                var b = (0 != this.id && !this.isVirus && !this.isAgitated && smoothRender > viewZoom);
                if (5 > this.getNumPoints()) b = true;
                if (this.wasSimpleDrawing && !b)
                    for (var c = 0; c < this.points.length; c++) this.points[c].size = this.size;
                this.wasSimpleDrawing = b;
                ctx.save();
                this.drawTime = timestamp;
                c = this.updatePos();
                this.destroyed && (ctx.globalAlpha *= 1 - c);
                ctx.lineWidth = 10;
                ctx.lineCap = "round";
                ctx.lineJoin = this.isVirus ? "miter" : "round";
                if (noColor) {
                    ctx.fillStyle = "#FFFFFF";
                    ctx.strokeStyle = "#AAAAAA";
                } else {
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = this.color;
                }
                if (b || simpleGreen == true) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI, false);
                } else {
                    this.movePoints();
                    ctx.beginPath();
                    var d = this.getNumPoints();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                    for (c = 1; c <= d; ++c) {
                        var e = c % d;
                        ctx.lineTo(this.points[e].x, this.points[e].y)
                    }
                }
                ctx.closePath();

                c = null;
                if (!this.isAgitated && !noSkin && ':teams' != gameMode) {

                    this.skinName = this.name.toLowerCase();

                    li = ps(this.skinName);

                    if (!this.isAgitated && this.skinName != "") {
                        if (!skins.hasOwnProperty(this.skinName)) {
                            skins[this.skinName] = new Image;
                            skins[this.skinName].src = './skins/' + li[0] + '.png';
                            skins[this.skinName].onload = function() {
                                skinsLoaded[this.src] = true;
                            }
                        }
                        if (0 != skins[this.skinName].width && skins[this.skinName].complete) {
                            c = skins[this.skinName];
                        } else {
                            c = null;
                        }
                    } else {
                        c = null;
                    }
                }

                c = (e = c) ? -1 != ib.indexOf(this.skinName) : false;
                b || ctx.stroke();
                ctx.fill();
                if (!(null == e || c)) {
                    if (skinsLoaded.hasOwnProperty(e.src)) {
                        ctx.save();
                        ctx.clip();
                        ctx.drawImage(e, this.x - this.size, this.y - this.size, 2 * this.size, 2 * this.size);
                        ctx.restore();
                    }
                }
                if ((noColor || 15 < this.size) && !b) {
                    ctx.strokeStyle = '#000000';
                    ctx.globalAlpha *= .1;
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
                if (null != e && c) {
                    if (skinsLoaded.hasOwnProperty(e.src)) {
                        ctx.drawImage(e, this.x - 2 * this.size, this.y - 2 * this.size, 4 * this.size, 4 * this.size);
                    }
                }
                c = -1 != playerCells.indexOf(this);
                var ncache;
                //draw name
                if (0 != this.id) {
                    var b = ~~this.y;
                    if ((!noNames || c) && this.name && this.nameCache) {
                        ncache = this.nameCache;
                        ncache.setValue(ps(this.name)[1]);
                        ncache.setSize(this.getNameSize());
                        var ratio = Math.ceil(10 * viewZoom) / 10;
                        ncache.setScale(ratio);
                        var rnchache = ncache.render(),
                            m = ~~(rnchache.width / ratio),
                            h = ~~(rnchache.height / ratio);
                        ctx.drawImage(rnchache, ~~this.x - ~~(m / 2), b - ~~(h / 2), m, h);
                        b += rnchache.height / 2 / ratio + 4
                    }

                    if (showScore == true && this.size > 35 && this.isVirus == false) {
                        ctx.fillStyle = "#FFFFFF";
                        ctx.font = (this.getNameSize() - 15) + "px Ubuntu";
                        var str = this.getScore();
                        var strWidth = ctx.measureText(str).width;
                        var xx = this.x - strWidth * .5;
                        ctx.fillText(str, xx, this.y + this.getNameSize() + 6);
                    }
                }
                ctx.restore()
            }
        }
    };
    UText.prototype = {
        _value: "",
        _color: "#000000",
        _stroke: false,
        _strokeColor: "#000000",
        _size: 16,
        _canvas: null,
        _ctx: null,
        _dirty: false,
        _scale: 1,
        setSize: function(a) {
            if (this._size != a) {
                this._size = a;
                this._dirty = true;
            }
        },
        setScale: function(a) {
            if (this._scale != a) {
                this._scale = a;
                this._dirty = true;
            }
        },
        setStrokeColor: function(a) {
            if (this._strokeColor != a) {
                this._strokeColor = a;
                this._dirty = true;
            }
        },
        setValue: function(a) {
            if (a != this._value) {
                this._value = a;
                this._dirty = true;
            }
        },
        render: function() {
            if (null == this._canvas) {
                this._canvas = document.createElement("canvas");
                this._ctx = this._canvas.getContext("2d");
            }
            if (this._dirty) {
                this._dirty = false;
                var canvas = this._canvas,
                    ctx = this._ctx,
                    value = this._value,
                    scale = this._scale,
                    fontsize = this._size,
                    font = fontsize + 'px Ubuntu';
                ctx.font = font;
                var h = ~~(.2 * fontsize);
                canvas.width = (ctx.measureText(value).width + 6) * scale;
                canvas.height = (fontsize + h) * scale;
                ctx.font = font;
                ctx.scale(scale, scale);
                ctx.globalAlpha = 1;
                ctx.lineWidth = 3;
                ctx.strokeStyle = this._strokeColor;
                ctx.fillStyle = this._color;
                this._stroke && ctx.strokeText(value, 3, fontsize - h / 2);
                ctx.fillText(value, 3, fontsize - h / 2)
            }
            return this._canvas
        },
        getWidth: function() {
            return (ctx.measureText(this._value).width +
                6);
        }
    };
    Date.now || (Date.now = function() {
        return (new Date).getTime()
    });
    var Quad = {
        init: function(args) {
            function Node(x, y, w, h, depth) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.depth = depth;
                this.items = [];
                this.nodes = []
            }

            var c = args.maxChildren || 2,
                d = args.maxDepth || 4;
            Node.prototype = {
                x: 0,
                y: 0,
                w: 0,
                h: 0,
                depth: 0,
                items: null,
                nodes: null,
                exists: function(selector) {
                    for (var i = 0; i < this.items.length; ++i) {
                        var item = this.items[i];
                        if (item.x >= selector.x && item.y >= selector.y && item.x < selector.x + selector.w && item.y < selector.y + selector.h) return true
                    }
                    if (0 != this.nodes.length) {
                        var self = this;
                        return this.findOverlappingNodes(selector, function(dir) {
                            return self.nodes[dir].exists(selector)
                        })
                    }
                    return false;
                },
                retrieve: function(item, callback) {
                    for (var i = 0; i < this.items.length; ++i) callback(this.items[i]);
                    if (0 != this.nodes.length) {
                        var self = this;
                        this.findOverlappingNodes(item, function(dir) {
                            self.nodes[dir].retrieve(item, callback)
                        })
                    }
                },
                insert: function(a) {
                    if (0 != this.nodes.length) {
                        this.nodes[this.findInsertNode(a)].insert(a);
                    } else {
                        if (this.items.length >= c && this.depth < d) {
                            this.devide();
                            this.nodes[this.findInsertNode(a)].insert(a);
                        } else {
                            this.items.push(a);
                        }
                    }
                },
                findInsertNode: function(a) {
                    return a.x < this.x + this.w / 2 ? a.y < this.y + this.h / 2 ? 0 : 2 : a.y < this.y + this.h / 2 ? 1 : 3
                },
                findOverlappingNodes: function(a, b) {
                    return a.x < this.x + this.w / 2 && (a.y < this.y + this.h / 2 && b(0) || a.y >= this.y + this.h / 2 && b(2)) || a.x >= this.x + this.w / 2 && (a.y < this.y + this.h / 2 && b(1) || a.y >= this.y + this.h / 2 && b(3)) ? true : false
                },
                devide: function() {
                    var a = this.depth + 1,
                        c = this.w / 2,
                        d = this.h / 2;
                    this.nodes.push(new Node(this.x, this.y, c, d, a));
                    this.nodes.push(new Node(this.x + c, this.y, c, d, a));
                    this.nodes.push(new Node(this.x, this.y + d, c, d, a));
                    this.nodes.push(new Node(this.x + c, this.y + d, c, d, a));
                    a = this.items;
                    this.items = [];
                    for (c = 0; c < a.length; c++) this.insert(a[c])
                },
                clear: function() {
                    for (var a = 0; a < this.nodes.length; a++) this.nodes[a].clear();
                    this.items.length = 0;
                    this.nodes.length = 0
                }
            };
            var internalSelector = {
                x: 0,
                y: 0,
                w: 0,
                h: 0
            };
            return {
                root: new Node(args.minX, args.minY, args.maxX - args.minX, args.maxY - args.minY, 0),
                insert: function(a) {
                    this.root.insert(a)
                },
                retrieve: function(a, b) {
                    this.root.retrieve(a, b)
                },
                retrieve2: function(a, b, c, d, callback) {
                    internalSelector.x = a;
                    internalSelector.y = b;
                    internalSelector.w = c;
                    internalSelector.h = d;
                    this.root.retrieve(internalSelector, callback)
                },
                exists: function(a) {
                    return this.root.exists(a)
                },
                clear: function() {
                    this.root.clear()
                }
            }
        }
    };
    wHandle.onload = window_onLoad;
})
(window, window.jQuery);
 
